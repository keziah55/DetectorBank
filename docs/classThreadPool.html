<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>A Hopf, Skip and a Jump: ThreadPool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">A Hopf, Skip and a Jump
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classThreadPool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ThreadPool Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A utility class to permit a single function to be run on multiple datasets concurrently.  
 <a href="classThreadPool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="thread__pool_8h_source.html">thread_pool.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad3b05a5053f8327e66968c814857972f"><td class="memItemLeft" align="right" valign="top"><a id="ad3b05a5053f8327e66968c814857972f"></a>
typedef std::function&lt; void(void *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#ad3b05a5053f8327e66968c814857972f">delegate_t</a></td></tr>
<tr class="memdesc:ad3b05a5053f8327e66968c814857972f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the delegate function each thread will run. <br /></td></tr>
<tr class="separator:ad3b05a5053f8327e66968c814857972f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a19d09fe2aacaeb65f65673e50f1eb162"><td class="memItemLeft" align="right" valign="top"><a id="a19d09fe2aacaeb65f65673e50f1eb162"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a19d09fe2aacaeb65f65673e50f1eb162">ThreadPool</a> (std::size_t numThreads=0)</td></tr>
<tr class="memdesc:a19d09fe2aacaeb65f65673e50f1eb162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a thread pool. <br /></td></tr>
<tr class="separator:a19d09fe2aacaeb65f65673e50f1eb162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d3d2ab618970605e684efc216655eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a44d3d2ab618970605e684efc216655eb">~ThreadPool</a> ()</td></tr>
<tr class="memdesc:a44d3d2ab618970605e684efc216655eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the thread pool.  <a href="#a44d3d2ab618970605e684efc216655eb">More...</a><br /></td></tr>
<tr class="separator:a44d3d2ab618970605e684efc216655eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a200736f28bdc262e80dc87bfb08972"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a0a200736f28bdc262e80dc87bfb08972">manifold</a> (<a class="el" href="classThreadPool.html#ad3b05a5053f8327e66968c814857972f">delegate_t</a> <a class="el" href="classThreadPool.html#aab40610bfe71877e484c98ee6bae32f8">delegate</a>, void **<a class="el" href="classThreadPool.html#af2d2d15d76d0c6666d2935efa48d08b9">params</a>, std::size_t jobs)</td></tr>
<tr class="memdesc:a0a200736f28bdc262e80dc87bfb08972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function in each of the threads, passing each one its own paramater set.  <a href="#a0a200736f28bdc262e80dc87bfb08972">More...</a><br /></td></tr>
<tr class="separator:a0a200736f28bdc262e80dc87bfb08972"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a56d3579fd1eee46f58a6c451f54b01ca"><td class="memItemLeft" align="right" valign="top"><a id="a56d3579fd1eee46f58a6c451f54b01ca"></a>
const std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a56d3579fd1eee46f58a6c451f54b01ca">threads</a></td></tr>
<tr class="memdesc:a56d3579fd1eee46f58a6c451f54b01ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of threads in pool. <br /></td></tr>
<tr class="separator:a56d3579fd1eee46f58a6c451f54b01ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a2c7f00a60c24e7fb3ee91caefe34a2c2"><td class="memItemLeft" align="right" valign="top"><a id="a2c7f00a60c24e7fb3ee91caefe34a2c2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a2c7f00a60c24e7fb3ee91caefe34a2c2">state</a> { <b>waiting</b>, 
<b>running</b>, 
<b>dying</b>, 
<b>dead</b>
 }<tr class="memdesc:a2c7f00a60c24e7fb3ee91caefe34a2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">thread state descriptor <br /></td></tr>
</td></tr>
<tr class="separator:a2c7f00a60c24e7fb3ee91caefe34a2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a10cc5088a1de95aaa45b087b2b626024"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a10cc5088a1de95aaa45b087b2b626024">wait_raise</a> (std::unique_lock&lt; std::mutex &gt; &amp;lk, const std::size_t to_check)</td></tr>
<tr class="memdesc:a10cc5088a1de95aaa45b087b2b626024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function: waits for a lock then deals with any exceptions propagated from the threads.  <a href="#a10cc5088a1de95aaa45b087b2b626024">More...</a><br /></td></tr>
<tr class="separator:a10cc5088a1de95aaa45b087b2b626024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9005d90b271d27755bce5601b8e204b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a9005d90b271d27755bce5601b8e204b1">dispatcher</a> (int id)</td></tr>
<tr class="memdesc:a9005d90b271d27755bce5601b8e204b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch jobs to the given delegate.  <a href="#a9005d90b271d27755bce5601b8e204b1">More...</a><br /></td></tr>
<tr class="separator:a9005d90b271d27755bce5601b8e204b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a71c268cae99b697932b2c4f91d5c15a7"><td class="memItemLeft" align="right" valign="top"><a id="a71c268cae99b697932b2c4f91d5c15a7"></a>
std::unique_ptr&lt; std::thread[]&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a71c268cae99b697932b2c4f91d5c15a7">workers</a></td></tr>
<tr class="memdesc:a71c268cae99b697932b2c4f91d5c15a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker threads. <br /></td></tr>
<tr class="separator:a71c268cae99b697932b2c4f91d5c15a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92de07fee061b44f0e9a8a8c5c5e41ad"><td class="memItemLeft" align="right" valign="top"><a id="a92de07fee061b44f0e9a8a8c5c5e41ad"></a>
std::unique_ptr&lt; enum <a class="el" href="classThreadPool.html#a2c7f00a60c24e7fb3ee91caefe34a2c2">state</a>[]&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a92de07fee061b44f0e9a8a8c5c5e41ad">states</a></td></tr>
<tr class="memdesc:a92de07fee061b44f0e9a8a8c5c5e41ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">State variables for each thread. <br /></td></tr>
<tr class="separator:a92de07fee061b44f0e9a8a8c5c5e41ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a9dbf33b62fc7d0f4c702fcdf85a57"><td class="memItemLeft" align="right" valign="top"><a id="ad1a9dbf33b62fc7d0f4c702fcdf85a57"></a>
std::unique_ptr&lt; std::exception_ptr[]&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#ad1a9dbf33b62fc7d0f4c702fcdf85a57">exceptions</a></td></tr>
<tr class="memdesc:ad1a9dbf33b62fc7d0f4c702fcdf85a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">exception_ptrs for each thread <br /></td></tr>
<tr class="separator:ad1a9dbf33b62fc7d0f4c702fcdf85a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d2d15d76d0c6666d2935efa48d08b9"><td class="memItemLeft" align="right" valign="top"><a id="af2d2d15d76d0c6666d2935efa48d08b9"></a>
void **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#af2d2d15d76d0c6666d2935efa48d08b9">params</a></td></tr>
<tr class="memdesc:af2d2d15d76d0c6666d2935efa48d08b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for each thread, passed to the runJobs function. <br /></td></tr>
<tr class="separator:af2d2d15d76d0c6666d2935efa48d08b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab40610bfe71877e484c98ee6bae32f8"><td class="memItemLeft" align="right" valign="top"><a id="aab40610bfe71877e484c98ee6bae32f8"></a>
<a class="el" href="classThreadPool.html#ad3b05a5053f8327e66968c814857972f">delegate_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#aab40610bfe71877e484c98ee6bae32f8">delegate</a></td></tr>
<tr class="memdesc:aab40610bfe71877e484c98ee6bae32f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The work the workers are supposed to perform. <br /></td></tr>
<tr class="separator:aab40610bfe71877e484c98ee6bae32f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac18e0d455ac8a6e221d3b7ac8aa9459"><td class="memItemLeft" align="right" valign="top"><a id="aac18e0d455ac8a6e221d3b7ac8aa9459"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#aac18e0d455ac8a6e221d3b7ac8aa9459">m</a></td></tr>
<tr class="memdesc:aac18e0d455ac8a6e221d3b7ac8aa9459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to control access to job packets. <br /></td></tr>
<tr class="separator:aac18e0d455ac8a6e221d3b7ac8aa9459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af179dc77ec95084f4d5b3a075bfe87d9"><td class="memItemLeft" align="right" valign="top"><a id="af179dc77ec95084f4d5b3a075bfe87d9"></a>
std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#af179dc77ec95084f4d5b3a075bfe87d9">cv</a></td></tr>
<tr class="memdesc:af179dc77ec95084f4d5b3a075bfe87d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition variable through which to notify workers that jobs are available. <br /></td></tr>
<tr class="separator:af179dc77ec95084f4d5b3a075bfe87d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43744dd5de03d990f655682bae0073c"><td class="memItemLeft" align="right" valign="top"><a id="ab43744dd5de03d990f655682bae0073c"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#ab43744dd5de03d990f655682bae0073c">remain</a></td></tr>
<tr class="memdesc:ab43744dd5de03d990f655682bae0073c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of the number of workers still to complete their job packets. <br /></td></tr>
<tr class="separator:ab43744dd5de03d990f655682bae0073c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A utility class to permit a single function to be run on multiple datasets concurrently. </p>
<p>The class may be instanced giving the number of concurrent threads to run, or by requesting 0 threads (the default value), a number will be chosen equal to the inherent concurrency of the platform on which the application will run.</p>
<p>The caller must prepare an array of parameter blocks ("jobs"). These along with the delegate function are passed to the <a class="el" href="classThreadPool.html#a0a200736f28bdc262e80dc87bfb08972" title="Execute a function in each of the threads, passing each one its own paramater set. ">manifold()</a> method, and each concurrent invocation of the delegate function will be passed a separate parameter block.</p>
<p>The number of jobs must be defined in the <a class="el" href="classThreadPool.html#a0a200736f28bdc262e80dc87bfb08972" title="Execute a function in each of the threads, passing each one its own paramater set. ">manifold()</a> call but need not be equal to the number of threads. If the number of jobs exceeds the number of threads, work will be performed in batches. The size of each batch is the number of threads given when the <a class="el" href="classThreadPool.html" title="A utility class to permit a single function to be run on multiple datasets concurrently. ">ThreadPool</a> object is created. <a class="el" href="classThreadPool.html#a0a200736f28bdc262e80dc87bfb08972" title="Execute a function in each of the threads, passing each one its own paramater set. ">manifold()</a> does not return until all jobs are complete.</p>
<p>Threads are reused across calls to <a class="el" href="classThreadPool.html#a0a200736f28bdc262e80dc87bfb08972" title="Execute a function in each of the threads, passing each one its own paramater set. ">manifold()</a>. When the <a class="el" href="classThreadPool.html" title="A utility class to permit a single function to be run on multiple datasets concurrently. ">ThreadPool</a> is destroyed, it closes down all threads and awaits their proper termination. </p>

<p class="definition">Definition at line <a class="el" href="thread__pool_8h_source.html#l00036">36</a> of file <a class="el" href="thread__pool_8h_source.html">thread_pool.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a44d3d2ab618970605e684efc216655eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d3d2ab618970605e684efc216655eb">&#9670;&nbsp;</a></span>~ThreadPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ThreadPool::~ThreadPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the thread pool. </p>
<p>Waits for all executive threads to terminate. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9005d90b271d27755bce5601b8e204b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9005d90b271d27755bce5601b8e204b1">&#9670;&nbsp;</a></span>dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPool::dispatcher </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatch jobs to the given delegate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>index into the params/states arrays to be used by this thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a200736f28bdc262e80dc87bfb08972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a200736f28bdc262e80dc87bfb08972">&#9670;&nbsp;</a></span>manifold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPool::manifold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classThreadPool.html#ad3b05a5053f8327e66968c814857972f">delegate_t</a>&#160;</td>
          <td class="paramname"><em>delegate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>jobs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a function in each of the threads, passing each one its own paramater set. </p>
<p>The number of jobs (== the number of paramater sets) is passed in the final argument. If this exceeds the number of threads in the pool, the jobs will be sequenced into batches. mainfold() will only return when all have been completed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delegate</td><td>The function each thread should call. </td></tr>
    <tr><td class="paramname">params</td><td>An array of pointers to parameters to pass. </td></tr>
    <tr><td class="paramname">jobs</td><td>Number of threads to run. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10cc5088a1de95aaa45b087b2b626024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10cc5088a1de95aaa45b087b2b626024">&#9670;&nbsp;</a></span>wait_raise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPool::wait_raise </td>
          <td>(</td>
          <td class="paramtype">std::unique_lock&lt; std::mutex &gt; &amp;&#160;</td>
          <td class="paramname"><em>lk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>to_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function: waits for a lock then deals with any exceptions propagated from the threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lk</td><td>The lock on which to wait </td></tr>
    <tr><td class="paramname">to_check</td><td>Number of threads running on this lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/keziah/onsets/DetectorBank/src/<a class="el" href="thread__pool_8h_source.html">thread_pool.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
