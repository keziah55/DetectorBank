<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>A Hopf, Skip and a Jump: slidingbuffer::UniqueAllocator&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">A Hopf, Skip and a Jump
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>slidingbuffer</b></li><li class="navelem"><a class="el" href="classslidingbuffer_1_1UniqueAllocator.html">UniqueAllocator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classslidingbuffer_1_1UniqueAllocator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">slidingbuffer::UniqueAllocator&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classslidingbuffer_1_1UniqueAllocator.html" title="UniqueAllocator replaces the std::allocator for the internal stuctures of SlidingBuffer. ">UniqueAllocator</a> replaces the std::allocator for the internal stuctures of <a class="el" href="classslidingbuffer_1_1SlidingBuffer.html" title="SlidingBuffer is class template which can be used when reading a data stream to provide access to the...">SlidingBuffer</a>.  
 <a href="classslidingbuffer_1_1UniqueAllocator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="uniqueallocator_8h_source.html">uniqueallocator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5994873ae9590a18166cde4c28fb8270"><td class="memItemLeft" align="right" valign="top"><a id="a5994873ae9590a18166cde4c28fb8270"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslidingbuffer_1_1UniqueAllocator.html#a5994873ae9590a18166cde4c28fb8270">value_type</a> = T</td></tr>
<tr class="memdesc:a5994873ae9590a18166cde4c28fb8270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of values to allocate. <br /></td></tr>
<tr class="separator:a5994873ae9590a18166cde4c28fb8270"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3070a7a764cbe2279f67059a14ab8671"><td class="memItemLeft" align="right" valign="top"><a id="a3070a7a764cbe2279f67059a14ab8671"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslidingbuffer_1_1UniqueAllocator.html#a3070a7a764cbe2279f67059a14ab8671">UniqueAllocator</a> () noexcept</td></tr>
<tr class="memdesc:a3070a7a764cbe2279f67059a14ab8671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constuctor. <br /></td></tr>
<tr class="separator:a3070a7a764cbe2279f67059a14ab8671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38da15b2334b05faf0f8ace3f51c6df"><td class="memTemplParams" colspan="2"><a id="ac38da15b2334b05faf0f8ace3f51c6df"></a>
template&lt;class U &gt; </td></tr>
<tr class="memitem:ac38da15b2334b05faf0f8ace3f51c6df"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>UniqueAllocator</b> (<a class="el" href="classslidingbuffer_1_1UniqueAllocator.html">UniqueAllocator</a>&lt; U &gt; const &amp;) noexcept</td></tr>
<tr class="separator:ac38da15b2334b05faf0f8ace3f51c6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2ccf096fd9095e345342f6f36b4389"><td class="memItemLeft" align="right" valign="top"><a id="aee2ccf096fd9095e345342f6f36b4389"></a>
<a class="el" href="classslidingbuffer_1_1UniqueAllocator.html#a5994873ae9590a18166cde4c28fb8270">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>allocate</b> (std::size_t n)</td></tr>
<tr class="separator:aee2ccf096fd9095e345342f6f36b4389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0f112bf1cba332f7a84dd7b5ce4e6a"><td class="memItemLeft" align="right" valign="top"><a id="a0f0f112bf1cba332f7a84dd7b5ce4e6a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>deallocate</b> (<a class="el" href="classslidingbuffer_1_1UniqueAllocator.html#a5994873ae9590a18166cde4c28fb8270">value_type</a> *p, std::size_t n) noexcept</td></tr>
<tr class="separator:a0f0f112bf1cba332f7a84dd7b5ce4e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580d23e55cb6ac5f05ffa417e98e666a"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a580d23e55cb6ac5f05ffa417e98e666a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classslidingbuffer_1_1UniqueAllocator.html#a580d23e55cb6ac5f05ffa417e98e666a">delete_if_ptr</a> (P *const &amp;p)</td></tr>
<tr class="memdesc:a580d23e55cb6ac5f05ffa417e98e666a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the argument matches a pointer type, delete the object at which it points.  <a href="#a580d23e55cb6ac5f05ffa417e98e666a">More...</a><br /></td></tr>
<tr class="separator:a580d23e55cb6ac5f05ffa417e98e666a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1305436457aca67970a5fb5dd5d6162"><td class="memTemplParams" colspan="2"><a id="ae1305436457aca67970a5fb5dd5d6162"></a>
template&lt;class P &gt; </td></tr>
<tr class="memitem:ae1305436457aca67970a5fb5dd5d6162"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classslidingbuffer_1_1UniqueAllocator.html#ae1305436457aca67970a5fb5dd5d6162">delete_if_ptr</a> (P const &amp;)</td></tr>
<tr class="memdesc:ae1305436457aca67970a5fb5dd5d6162"><td class="mdescLeft">&#160;</td><td class="mdescRight">If P isn't a pointer type, ignore this call. <br /></td></tr>
<tr class="separator:ae1305436457aca67970a5fb5dd5d6162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3707d49e45459db3f792c260c137ab33"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a3707d49e45459db3f792c260c137ab33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classslidingbuffer_1_1UniqueAllocator.html#a3707d49e45459db3f792c260c137ab33">destroy</a> (U *p) noexcept</td></tr>
<tr class="memdesc:a3707d49e45459db3f792c260c137ab33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy (but don't deallocate) the collection member.  <a href="#a3707d49e45459db3f792c260c137ab33">More...</a><br /></td></tr>
<tr class="separator:a3707d49e45459db3f792c260c137ab33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class slidingbuffer::UniqueAllocator&lt; T &gt;</h3>

<p><a class="el" href="classslidingbuffer_1_1UniqueAllocator.html" title="UniqueAllocator replaces the std::allocator for the internal stuctures of SlidingBuffer. ">UniqueAllocator</a> replaces the std::allocator for the internal stuctures of <a class="el" href="classslidingbuffer_1_1SlidingBuffer.html" title="SlidingBuffer is class template which can be used when reading a data stream to provide access to the...">SlidingBuffer</a>. </p>
<p>Containers using this allocator can conveniently be used to hold pointers to dynamically allocated objects, so long as the only access to the objecs is uniquely through the container.</p>
<p>Since the pointers are stored uniquely in their particular collection, <a class="el" href="classslidingbuffer_1_1UniqueAllocator.html" title="UniqueAllocator replaces the std::allocator for the internal stuctures of SlidingBuffer. ">UniqueAllocator</a> provides a method which deletes the referenced object when its pointer is deleted. This combines efficiency of access with guaranteed deallocation.</p>
<p>e.g., <a class="el" href="classslidingbuffer_1_1SlidingBuffer.html" title="SlidingBuffer is class template which can be used when reading a data stream to provide access to the...">SlidingBuffer</a> maintains a container of Segments internally. These segments are allocated dynamically, and it is their addresses which are stored. In order to maximise efficiency, the addresses are stored as raw pointers, but this might lead to memory leaks when the pointers are deallocated. </p>

<p class="definition">Definition at line <a class="el" href="uniqueallocator_8h_source.html#l00033">33</a> of file <a class="el" href="uniqueallocator_8h_source.html">uniqueallocator.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a580d23e55cb6ac5f05ffa417e98e666a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580d23e55cb6ac5f05ffa417e98e666a">&#9670;&nbsp;</a></span>delete_if_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslidingbuffer_1_1UniqueAllocator.html">slidingbuffer::UniqueAllocator</a>&lt; T &gt;::delete_if_ptr </td>
          <td>(</td>
          <td class="paramtype">P *const &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the argument matches a pointer type, delete the object at which it points. </p>
<p>The assumption is that pointers held in the container are obtained by calling the relevant new to allocate an object dynamically. If this isn't the case, this isn't an appropriate allocator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to object to be deleted </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="uniqueallocator_8h_source.html#l00065">65</a> of file <a class="el" href="uniqueallocator_8h_source.html">uniqueallocator.h</a>.</p>

</div>
</div>
<a id="a3707d49e45459db3f792c260c137ab33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3707d49e45459db3f792c260c137ab33">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslidingbuffer_1_1UniqueAllocator.html">slidingbuffer::UniqueAllocator</a>&lt; T &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy (but don't deallocate) the collection member. </p>
<p>Since the collection is expected to contain pointers to objects allocated with new(), <a class="el" href="classslidingbuffer_1_1UniqueAllocator.html#a580d23e55cb6ac5f05ffa417e98e666a" title="If the argument matches a pointer type, delete the object at which it points. ">delete_if_ptr()</a> is called to delete the object at which the collection element points. This checks the type of the collection element and will not attempt to call delete on a non-pointer type.</p>
<p>However, one would normally expect the referenced object to be deleted, then the pointer within the collection destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to object to be destroyed </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="uniqueallocator_8h_source.html#l00084">84</a> of file <a class="el" href="uniqueallocator_8h_source.html">uniqueallocator.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/keziah/onsets/DetectorBank/src/<a class="el" href="uniqueallocator_8h_source.html">uniqueallocator.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
