<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>A Hopf, Skip and a Jump: SlidingBuffer: Internal Operation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">A Hopf, Skip and a Jump
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">SlidingBuffer: Internal Operation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section explains in greater deatail the internal workings of the <a class="el" href="classslidingbuffer_1_1SlidingBuffer.html">SlidingBuffer</a> to assist with its extension, and to demonstrate its features and limitations.</p>
<p>There are many applications which need to refer to the recent history of an input data stream. Examples of such might include image identification and tracking, audio feature identification and, the reason for which this template class was developed, identification and localisation of the onset of musical notes in an audio stream. Processing proceeds in the forward direction, starting at the beginning of the stream, but occasionally makes reference to the frames in the recent past. It is very convenient to be able to refer to recent data frames simply by their position in the stream, but reading them all into memory ahead of time may be impractical if the stream is unbounded or real-time operation is required. The idea of the SlidingBuffer is to cache recent frames from the input stream, permitting a an application to refer to them directly by there index using the <code>[]</code> operator. Thus the stream appears to be a single long array, so long as references are not made too far into the past.</p>
<p>Suppose a SlidingBuffer has been instantiated with a maximum of four segments each containing <code>size</code> integer entities. An additional instance of class <code>IntGenerator</code> has been provided, <code>myInts</code>, derived from <code>slidingbuffer:SegmentProducer</code>, to fill such segments.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceslidingbuffer.html">slidingbuffer</a>;</div><div class="line"></div><div class="line"><a class="code" href="classslidingbuffer_1_1SlidingBuffer.html">SlidingBuffer&lt;int, Segment&lt;int&gt;</a>, IntGenerator&gt; sb(4, size, myInts);</div><div class="line"></div><div class="line">sb[0];</div></div><!-- fragment --><p>The act of accessing the 0th entity in the sliding buffer will cause the SegmentProducer's <a class="el" href="classslidingbuffer_1_1SegmentProducer.html"><code>generate()</code></a> method to be invoked, and to fill one segment with data. The calling program may now access indices up to <code>[size-1]</code> without further invocation of <code>generate()</code>.</p>
<p>As the index into the buffer increases above <code>[3*size]</code> (but strictly less than <code>[4*size]</code>), the data held in the SlidingBuffer will be represented as in the following diagram. At this stage, all of the integers generated so far, from <code>sb[0]</code> to <code>sb[4*size-1]</code> will be accessible.</p>
<p><div class="dotgraph">
<img src="dot_slidingbuf-oneseg.png" alt="dot_slidingbuf-oneseg.png" border="0" usemap="#dot_slidingbuf-oneseg.map"/>
<map name="dot_slidingbuf-oneseg.map" id="dot_slidingbuf-oneseg.map"></map>
<div class="caption">
Data in the buffer after sb[3*size] has been accessed.</div>
</div>
</p>
<p>After index <code>[4*size]</code> has been accessed, the 4th call to <code>generate()</code> produces another buffer segment. However, since the maximum size of the SlidingBuffer was declared to be 4 Segments when it was constructed, the 0th segment along with all of its contained entities are destroyed.</p>
<p>The storage disposition is now as shown in the following diagram; integers with indices of at least <code>[size]</code> but less than <code>[5*size]</code> can be accessed.</p>
<p>SlidingBuffers do bounds checking, throwing an instance of an object derived from <a class="el" href="classslidingbuffer_1_1SlidingBufferException.html" title="The base class for all exceptions thrown by a SlidingBuffer. ">slidingbuffer::SlidingBufferException</a>. These are:</p>
<ul>
<li><a class="el" href="classslidingbuffer_1_1NegativeIndexException.html" title="Exception thrown when an attempt was made to access a negative index in the SlidingBuffer. ">slidingbuffer::NegativeIndexException</a> when an attempt is made to access an entity at index less than 0;</li>
<li><a class="el" href="classslidingbuffer_1_1IndexOutOfRangeException.html" title="Exception thown when the entity at position &#39;index&#39; is not yet available and the SegmentProducer for ...">slidingbuffer::IndexOutOfRangeException</a> when an attempt is made to access an entity which is at an index greater than the maximum currently stored, and the Producer is unable to supply any further data (perhaps it has been supplying data from a file and reached the end of the file);</li>
<li><a class="el" href="classslidingbuffer_1_1ExpiredIndexException.html" title="Exception thrown when an apparently valid index (positive, within the extent of the data read so far)...">slidingbuffer::ExpiredIndexException</a> when the SlidingBuffer has already discarded the entity requested in order to make space for furter entities to be generated.</li>
</ul>
<p><div class="dotgraph">
<img src="dot_slidingbuf-manyseg.png" alt="dot_slidingbuf-manyseg.png" border="0" usemap="#dot_slidingbuf-manyseg.map"/>
<map name="dot_slidingbuf-manyseg.map" id="dot_slidingbuf-manyseg.map"></map>
<div class="caption">
Data in the buffer after sb[4*size] has been accessed.</div>
</div>
</p>
<p>Should the index skip forward to the extent that several segments are never used, the SlidingBuffer will nonetheless call <code>generate()</code> to read intervening samples before discarding them. This enables a Producer which is in some respect maintains the current input position and relies upon it to return correct data to perform correctly even when the input position jumps forward abruptly.</p>
<p>A minimal example exercising these features is shown in the C++ example below.</p>
<div class="fragment"><div class="line"><span class="comment">// Compile with g++ -I../src slidingbuffertest.cpp</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstddef&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;slidingbuffer.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>std;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>intsProducer : <span class="keyword">public</span> <a class="code" href="classslidingbuffer_1_1SegmentProducer.html">slidingbuffer::SegmentProducer</a>&lt;int&gt;</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> constexpr <span class="keywordtype">size_t</span> maxindex = 65;</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span> invoc;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">size_t</span> generate(<span class="keywordtype">int</span> seg[],</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">size_t</span> idx,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">size_t</span> size) {</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;\nGenerating segment &quot;</span> &lt;&lt; invoc </div><div class="line">             &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">&quot; ints, org=&quot;</span> &lt;&lt; idx &lt;&lt; <span class="stringliteral">&quot;) at &quot;</span> &lt;&lt; seg;</div><div class="line">        </div><div class="line">        <span class="keywordtype">size_t</span> i { 0 };</div><div class="line">        <span class="keywordflow">while</span> (i &lt; size &amp;&amp; (i + idx) &lt; maxindex) {</div><div class="line">            seg[i] = 1000*invoc + i;</div><div class="line">            ++i;</div><div class="line">        }</div><div class="line">        </div><div class="line">        ++invoc;</div><div class="line"></div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;. Generated &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;\n\t    ...&quot;</span>;</div><div class="line">        <span class="keywordflow">return</span> i;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keywordtype">bool</span> more(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> invoc &lt; 7; }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> intsProducer::invoc = 1;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    intsProducer ip;</div><div class="line">    <span class="comment">// SlidingBuffer with 4 segments each 6 long.</span></div><div class="line">    <a class="code" href="classslidingbuffer_1_1SlidingBuffer.html">slidingbuffer::SlidingBuffer</a>&lt;int,</div><div class="line">                                 <a class="code" href="classslidingbuffer_1_1Segment.html">slidingbuffer::Segment&lt;int, intsProducer&gt;</a>,</div><div class="line">                                 intsProducer&gt; sb(ip, 4, 6);</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i { 0 }; i &lt; 80; i++) {</div><div class="line">        <span class="comment">//int h { 0 };</span></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> h { 0 }; h &gt; -24; h-=8) {</div><div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;sb[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; + (&quot;</span>&lt;&lt; h &lt;&lt; <span class="stringliteral">&quot;)] = &quot;</span>;</div><div class="line">            <span class="keywordflow">try</span> {</div><div class="line">                cout &lt;&lt; sb[i+h] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;</div><div class="line">            } <span class="keywordflow">catch</span> (<a class="code" href="classslidingbuffer_1_1IndexOutOfRangeException.html">slidingbuffer::IndexOutOfRangeException</a> e) {</div><div class="line">                cout &lt;&lt; <span class="stringliteral">&quot;&lt;EoD&gt;(&quot;</span> &lt;&lt; e.<a class="code" href="classslidingbuffer_1_1SlidingBufferException.html#ad810518cb784d0bfa4ba8ae1ce5d3bf6">index</a> &lt;&lt; <span class="stringliteral">&quot;) \t&quot;</span>;</div><div class="line">            } <span class="keywordflow">catch</span> (<a class="code" href="classslidingbuffer_1_1SlidingBufferException.html">slidingbuffer::SlidingBufferException</a> e) {</div><div class="line">                cout &lt;&lt; <span class="stringliteral">&quot;&lt;OOR&gt;(&quot;</span> &lt;&lt; e.<a class="code" href="classslidingbuffer_1_1SlidingBufferException.html#ad810518cb784d0bfa4ba8ae1ce5d3bf6">index</a> &lt;&lt; <span class="stringliteral">&quot;) \t&quot;</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        cout &lt;&lt; endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>In normal usage, because there is a noticable fetch overhead in returning a single entity, so one would expect them to be larger than a simple type. In the case that the entities are essentially simple, or at least one-dimensional types, appropriate templates may be used to provide the desired functionalities. Two and higher dimensions require additional effort to redefine the <code>operator[]</code> access method depending on their semantics.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslidingbuffer_1_1SlidingBuffer.html" title="SlidingBuffer is class template which can be used when reading a data stream to provide access to the...">slidingbuffer::SlidingBuffer</a> </dd>
<dd>
<a class="el" href="classdetectorcache_1_1DetectorCache.html" title="Cache results from a detectorbank. ">detectorcache::DetectorCache</a> </dd>
<dd>
<a class="el" href="DetectorCacheDesign.html">DetectorCache design</a> </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
